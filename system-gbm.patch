From 505eaf5774a2d39cd703ba2cb91fb670683c0b8e Mon Sep 17 00:00:00 2001
From: Akarshan Biswas <akarshan.biswas@gmail.com>
Date: Fri, 28 Dec 2018 13:58:59 +0530
Subject: [PATCH] TEST:Make gbm_wrapper to be compiled

---
 ui/ozone/common/linux/gbm_wrapper.cc | 157 +++++++++++++++++++++------
 1 file changed, 124 insertions(+), 33 deletions(-)

diff --git a/ui/ozone/common/linux/gbm_wrapper.cc b/ui/ozone/common/linux/gbm_wrapper.cc
index ba55b0e56..2705f9b1c 100644
--- a/ui/ozone/common/linux/gbm_wrapper.cc
+++ b/ui/ozone/common/linux/gbm_wrapper.cc
@@ -4,7 +4,9 @@
 
 #include "ui/ozone/common/linux/gbm_wrapper.h"
 
+#include <fcntl.h>
 #include <gbm.h>
+#include <xf86drm.h>
 
 #include "base/posix/eintr_wrapper.h"
 #include "third_party/skia/include/core/SkSurface.h"
@@ -15,6 +17,86 @@
 
 namespace gbm_wrapper {
 
+namespace {
+
+// Temporary defines while we migrate to GBM_BO_IMPORT_FD_MODIFIER.
+#define GBM_BO_IMPORT_FD_PLANAR_5504 0x5504
+#define GBM_BO_IMPORT_FD_PLANAR_5505 0x5505
+
+// Minigbm and system linux gbm have some differences. There is no clear way how
+// to distinguish linux gbm (Mesa, basically) and minigbm, which can be both
+// third_party and minigbm. Thus, use GBM_BO_IMPORT_FD_PLANAR define to
+// identify, which gbm is used.
+#if defined(GBM_BO_IMPORT_FD_PLANAR)
+// There are some methods, which require knowing whether minigbm is used or not.
+#ifndef USING_MINIGBM
+#define USING_MINIGBM
+#endif  // USING_MINIGBM
+// Minigbm and system linux gbm have alike gbm_bo_import* structures, but some
+// of the data variables have different type.
+using gbm_bo_import_fd_data_with_modifier = struct gbm_import_fd_planar_data;
+#else
+using gbm_bo_import_fd_data_with_modifier = struct gbm_import_fd_modifier_data;
+#endif
+
+void InitializeImportData(uint32_t format,
+                          const gfx::Size& size,
+                          const std::vector<base::ScopedFD>& fds,
+                          const std::vector<gfx::NativePixmapPlane>& planes,
+                          gbm_bo_import_fd_data_with_modifier* fd_data) {
+  fd_data->width = size.width();
+  fd_data->height = size.height();
+  fd_data->format = format;
+
+  DCHECK_LE(planes.size(), 3u);
+  for (size_t i = 0; i < planes.size(); ++i) {
+    fd_data->fds[i] = fds[i < fds.size() ? i : 0].get();
+    fd_data->strides[i] = planes[i].stride;
+    fd_data->offsets[i] = planes[i].offset;
+#if defined(USING_MINIGBM)
+    fd_data->format_modifiers[i] = planes[i].modifier;
+#else
+    fd_data->modifier = planes[i].modifier;
+#endif
+  }
+}
+
+int GetPlaneFdForBo(gbm_bo* bo, size_t plane) {
+  DCHECK(plane < gbm_bo_get_plane_count(bo));
+
+  // System linux gbm (or Mesa gbm) does not provide fds per plane basis. Thus,
+  // get plane handle and use drm ioctl to get a prime fd out of it avoid having
+  // two different branches for minigbm and Mesa gbm here.
+  gbm_device* gbm_dev = gbm_bo_get_device(bo);
+  int dev_fd = gbm_device_get_fd(gbm_dev);
+  if (dev_fd <= 0) {
+    LOG(ERROR) << "Unable to get device fd";
+    return -1;
+  }
+
+  const uint32_t plane_handle = gbm_bo_get_handle_for_plane(bo, plane).u32;
+  int fd = -1;
+  int ret;
+  // Use DRM_RDWR to allow the fd to be mappable in another process.
+  ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC | DRM_RDWR, &fd);
+
+  // Older DRM implementations blocked DRM_RDWR, but gave a read/write mapping
+  // anyways
+  if (ret)
+    ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC, &fd);
+
+  return ret ? ret : fd;
+}
+
+size_t GetSizeOfPlane(gbm_bo* bo, size_t plane) {
+  // System linux gbm (or Mesa gbm) does not provide plane size. Thus, calculate
+  // it by ourselves and avoid having two different branches for minigbm and
+  // Mesa gbm here.
+  return gbm_bo_get_height(bo) * gbm_bo_get_stride_for_plane(bo, plane);
+}
+
+}  // namespace
+
 class Buffer final : public ui::GbmBuffer {
  public:
   Buffer(struct gbm_bo* bo,
@@ -76,7 +158,7 @@ class Buffer final : public ui::GbmBuffer {
   }
   uint32_t GetPlaneHandle(size_t plane) const override {
     DCHECK_LT(plane, planes_.size());
-    return gbm_bo_get_plane_handle(bo_, plane).u32;
+    return gbm_bo_get_handle_for_plane(bo_, plane).u32;
   }
   uint32_t GetHandle() const override { return gbm_bo_get_handle(bo_).u32; }
   gfx::NativePixmapHandle ExportHandle() const override {
@@ -106,7 +188,12 @@ class Buffer final : public ui::GbmBuffer {
     uint32_t stride;
     void* addr;
     addr = gbm_bo_map(bo_, 0, 0, gbm_bo_get_width(bo_), gbm_bo_get_height(bo_),
-                      GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_, 0);
+                      GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_
+#if defined(USING_MINIGBM)
+                      ,
+                      0
+#endif
+                      );
 
     if (!addr)
       return nullptr;
@@ -147,11 +234,18 @@ std::unique_ptr<Buffer> CreateBufferForBO(struct gbm_bo* bo,
   std::vector<base::ScopedFD> fds;
   std::vector<gfx::NativePixmapPlane> planes;
 
-  const uint64_t modifier = gbm_bo_get_format_modifier(bo);
-  for (size_t i = 0; i < gbm_bo_get_num_planes(bo); ++i) {
+  const uint64_t modifier = gbm_bo_get_modifier(bo);
+  const int plane_count = gbm_bo_get_plane_count(bo);
+  // The Mesa's gbm implementation explicitly checks whether plane count <= and
+  // returns 1 if the condition is true. Nevertheless, use a DCHECK here to make
+  // sure the condition is not broken there.
+  DCHECK(plane_count > 0);
+  // Ensure there are no differences in integer signs by casting any possible
+  // values to size_t.
+  for (size_t i = 0; i < static_cast<size_t>(plane_count); ++i) {
     // The fd returned by gbm_bo_get_fd is not ref-counted and need to be
     // kept open for the lifetime of the buffer.
-    base::ScopedFD fd(gbm_bo_get_plane_fd(bo, i));
+    base::ScopedFD fd(GetPlaneFdForBo(bo, i));
 
     // TODO(dcastagna): support multiple fds.
     // crbug.com/642410
@@ -164,9 +258,9 @@ std::unique_ptr<Buffer> CreateBufferForBO(struct gbm_bo* bo,
       fds.emplace_back(std::move(fd));
     }
 
-    planes.emplace_back(gbm_bo_get_plane_stride(bo, i),
-                        gbm_bo_get_plane_offset(bo, i),
-                        gbm_bo_get_plane_size(bo, i), modifier);
+    planes.emplace_back(gbm_bo_get_stride_for_plane(bo, i),
+                        gbm_bo_get_offset(bo, i), GetSizeOfPlane(bo, i),
+                        modifier);
   }
   return std::make_unique<Buffer>(bo, format, flags, modifier, std::move(fds),
                                   size, std::move(planes));
@@ -213,35 +307,32 @@ class Device final : public ui::GbmDevice {
     DCHECK_EQ(planes[0].offset, 0);
 
     // Try to use scanout if supported.
-    int gbm_flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_TEXTURING;
+    int gbm_flags = GBM_BO_USE_SCANOUT;
+#if defined(USING_MINIGBM)
+    gbm_flags |= GBM_BO_USE_TEXTURING;
+#endif
     if (!gbm_device_is_format_supported(device_, format, gbm_flags))
       gbm_flags &= ~GBM_BO_USE_SCANOUT;
 
     struct gbm_bo* bo = nullptr;
-    if (!gbm_device_is_format_supported(device_, format, gbm_flags)) {
-      LOG(ERROR) << "gbm format not supported: " << format;
-      return nullptr;
-    }
-
-    struct gbm_import_fd_planar_data fd_data;
-    fd_data.width = size.width();
-    fd_data.height = size.height();
-    fd_data.format = format;
-
-    DCHECK_LE(planes.size(), 3u);
-    for (size_t i = 0; i < planes.size(); ++i) {
-      fd_data.fds[i] = fds[i < fds.size() ? i : 0].get();
-      fd_data.strides[i] = planes[i].stride;
-      fd_data.offsets[i] = planes[i].offset;
-      fd_data.format_modifiers[i] = planes[i].modifier;
-    }
-
-    // The fd passed to gbm_bo_import is not ref-counted and need to be
-    // kept open for the lifetime of the buffer.
-    bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR, &fd_data, gbm_flags);
-    if (!bo) {
-      LOG(ERROR) << "nullptr returned from gbm_bo_import";
-      return nullptr;
+    if (gbm_device_is_format_supported(device_, format, gbm_flags)) {
+      gbm_bo_import_fd_data_with_modifier fd_data;
+      InitializeImportData(format, size, fds, planes, &fd_data);
+
+      // The fd passed to gbm_bo_import is not ref-counted and need to be
+      // kept open for the lifetime of the buffer.
+      //
+      // See the comment regarding the GBM_BO_IMPORT_FD_PLANAR_550X above.
+      bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5505, &fd_data,
+                         gbm_flags);
+      if (!bo) {
+        bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5504, &fd_data,
+                           gbm_flags);
+        if (!bo) {
+          LOG(ERROR) << "nullptr returned from gbm_bo_import";
+          return nullptr;
+        }
+      }
     }
 
     return std::make_unique<Buffer>(bo, format, gbm_flags, planes[0].modifier,
-- 
2.20.1

